{"version":3,"file":"route.cjs","sources":["../../src/route.ts"],"sourcesContent":["import invariant from 'tiny-invariant'\nimport { joinPaths, rootRouteId, trimPathLeft } from '@tanstack/router-core'\nimport { useLoaderData } from './useLoaderData'\nimport { useLoaderDeps } from './useLoaderDeps'\nimport { useParams } from './useParams'\nimport { useSearch } from './useSearch'\nimport { notFound } from './not-found'\nimport { useNavigate } from './useNavigate'\nimport { useMatch } from './useMatch'\nimport type {\n  AnyContext,\n  AnyPathParams,\n  AnySchema,\n  AnyValidator,\n  Assign,\n  Constrain,\n  ConstrainLiteral,\n  ContextAsyncReturnType,\n  ContextReturnType,\n  DefaultValidator,\n  ErrorComponentProps,\n  Expand,\n  InferAllContext,\n  InferAllParams,\n  InferFullSearchSchema,\n  InferFullSearchSchemaInput,\n  IntersectAssign,\n  NoInfer,\n  NotFoundRouteProps,\n  ParamsOptions,\n  ParsedLocation,\n  ResolveId,\n  ResolveLoaderData,\n  ResolveParams,\n  ResolveRouteContext,\n  ResolveSearchValidatorInput,\n  ResolveValidatorOutput,\n  RootRouteId,\n  RouteContext,\n  RoutePathOptions,\n  RoutePathOptionsIntersection,\n  RoutePrefix,\n  SearchFilter,\n  SearchMiddleware,\n  TrimPathRight,\n  UpdatableStaticRouteOption,\n} from '@tanstack/router-core'\nimport type { UseLoaderDataRoute } from './useLoaderData'\nimport type { UseMatchRoute } from './useMatch'\nimport type { UseLoaderDepsRoute } from './useLoaderDeps'\nimport type { UseParamsRoute } from './useParams'\nimport type { UseSearchRoute } from './useSearch'\nimport type * as React from 'react'\nimport type { UseNavigateResult } from './useNavigate'\nimport type {\n  AnyRouteMatch,\n  MakeRouteMatchFromRoute,\n  MakeRouteMatchUnion,\n  RouteMatch,\n} from './Matches'\nimport type { NavigateOptions, ToMaskOptions } from './link'\nimport type { ParseRoute, RouteById, RouteIds, RoutePaths } from './routeInfo'\nimport type { AnyRouter, RegisteredRouter, Router } from './router'\nimport type { BuildLocationFn, NavigateFn } from './RouterProvider'\nimport type { NotFoundError } from './not-found'\nimport type { LazyRoute } from './fileRoute'\n\nimport type { UseRouteContextRoute } from './useRouteContext'\n\nexport type RouteOptions<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TId extends string = string,\n  TCustomId extends string = string,\n  TFullPath extends string = string,\n  TPath extends string = string,\n  TSearchValidator = undefined,\n  TParams = AnyPathParams,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderFn = undefined,\n  TRouterContext = {},\n  TRouteContextFn = AnyContext,\n  TBeforeLoadFn = AnyContext,\n> = BaseRouteOptions<\n  TParentRoute,\n  TId,\n  TCustomId,\n  TPath,\n  TSearchValidator,\n  TParams,\n  TLoaderDeps,\n  TLoaderFn,\n  TRouterContext,\n  TRouteContextFn,\n  TBeforeLoadFn\n> &\n  UpdatableRouteOptions<\n    NoInfer<TParentRoute>,\n    NoInfer<TCustomId>,\n    NoInfer<TFullPath>,\n    NoInfer<TParams>,\n    NoInfer<TSearchValidator>,\n    NoInfer<TLoaderFn>,\n    NoInfer<TLoaderDeps>,\n    NoInfer<TRouterContext>,\n    NoInfer<TRouteContextFn>,\n    NoInfer<TBeforeLoadFn>\n  >\n\nexport interface FullSearchSchemaOption<\n  in out TParentRoute extends AnyRoute,\n  in out TSearchValidator,\n> {\n  search: Expand<ResolveFullSearchSchema<TParentRoute, TSearchValidator>>\n}\n\nexport type RouteContextFn<\n  in out TParentRoute extends AnyRoute,\n  in out TSearchValidator,\n  in out TParams,\n  in out TRouterContext,\n> = (\n  ctx: RouteContextOptions<\n    TParentRoute,\n    TSearchValidator,\n    TParams,\n    TRouterContext\n  >,\n) => any\n\nexport type BeforeLoadFn<\n  in out TParentRoute extends AnyRoute,\n  in out TSearchValidator,\n  in out TParams,\n  in out TRouterContext,\n  in out TRouteContextFn,\n> = (\n  ctx: BeforeLoadContextOptions<\n    TParentRoute,\n    TSearchValidator,\n    TParams,\n    TRouterContext,\n    TRouteContextFn\n  >,\n) => any\n\nexport type FileBaseRouteOptions<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TId extends string = string,\n  TPath extends string = string,\n  TSearchValidator = undefined,\n  TParams = {},\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderFn = undefined,\n  TRouterContext = {},\n  TRouteContextFn = AnyContext,\n  TBeforeLoadFn = AnyContext,\n  TRemountDepsFn = AnyContext,\n> = ParamsOptions<TPath, TParams> & {\n  validateSearch?: Constrain<TSearchValidator, AnyValidator, DefaultValidator>\n\n  shouldReload?:\n    | boolean\n    | ((\n        match: LoaderFnContext<\n          TParentRoute,\n          TId,\n          TParams,\n          TLoaderDeps,\n          TRouterContext,\n          TRouteContextFn,\n          TBeforeLoadFn\n        >,\n      ) => any)\n\n  context?: Constrain<\n    TRouteContextFn,\n    (\n      ctx: RouteContextOptions<\n        TParentRoute,\n        TParams,\n        TRouterContext,\n        TLoaderDeps\n      >,\n    ) => any\n  >\n\n  // This async function is called before a route is loaded.\n  // If an error is thrown here, the route's loader will not be called.\n  // If thrown during a navigation, the navigation will be cancelled and the error will be passed to the `onError` function.\n  // If thrown during a preload event, the error will be logged to the console.\n  beforeLoad?: Constrain<\n    TBeforeLoadFn,\n    (\n      ctx: BeforeLoadContextOptions<\n        TParentRoute,\n        TSearchValidator,\n        TParams,\n        TRouterContext,\n        TRouteContextFn\n      >,\n    ) => any\n  >\n\n  loaderDeps?: (\n    opts: FullSearchSchemaOption<TParentRoute, TSearchValidator>,\n  ) => TLoaderDeps\n\n  remountDeps?: Constrain<\n    TRemountDepsFn,\n    (\n      opt: RemountDepsOptions<\n        TId,\n        FullSearchSchemaOption<TParentRoute, TSearchValidator>,\n        Expand<ResolveAllParamsFromParent<TParentRoute, TParams>>,\n        TLoaderDeps\n      >,\n    ) => any\n  >\n\n  loader?: Constrain<\n    TLoaderFn,\n    (\n      ctx: LoaderFnContext<\n        TParentRoute,\n        TId,\n        TParams,\n        TLoaderDeps,\n        TRouterContext,\n        TRouteContextFn,\n        TBeforeLoadFn\n      >,\n    ) => any\n  >\n}\n\nexport type BaseRouteOptions<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TId extends string = string,\n  TCustomId extends string = string,\n  TPath extends string = string,\n  TSearchValidator = undefined,\n  TParams = {},\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderFn = undefined,\n  TRouterContext = {},\n  TRouteContextFn = AnyContext,\n  TBeforeLoadFn = AnyContext,\n> = RoutePathOptions<TCustomId, TPath> &\n  FileBaseRouteOptions<\n    TParentRoute,\n    TId,\n    TPath,\n    TSearchValidator,\n    TParams,\n    TLoaderDeps,\n    TLoaderFn,\n    TRouterContext,\n    TRouteContextFn,\n    TBeforeLoadFn\n  > & {\n    getParentRoute: () => TParentRoute\n  }\n\nexport interface ContextOptions<\n  in out TParentRoute extends AnyRoute,\n  in out TParams,\n> {\n  abortController: AbortController\n  preload: boolean\n  params: Expand<ResolveAllParamsFromParent<TParentRoute, TParams>>\n  location: ParsedLocation\n  /**\n   * @deprecated Use `throw redirect({ to: '/somewhere' })` instead\n   **/\n  navigate: NavigateFn\n  buildLocation: BuildLocationFn\n  cause: 'preload' | 'enter' | 'stay'\n  matches: Array<MakeRouteMatchUnion>\n}\n\nexport interface RouteContextOptions<\n  in out TParentRoute extends AnyRoute,\n  in out TParams,\n  in out TRouterContext,\n  in out TLoaderDeps,\n> extends ContextOptions<TParentRoute, TParams> {\n  deps: TLoaderDeps\n  context: Expand<RouteContextParameter<TParentRoute, TRouterContext>>\n}\n\nexport interface RemountDepsOptions<\n  in out TRouteId,\n  in out TFullSearchSchema,\n  in out TAllParams,\n  in out TLoaderDeps,\n> {\n  routeId: TRouteId\n  search: TFullSearchSchema\n  params: TAllParams\n  loaderDeps: TLoaderDeps\n}\n\nexport type MakeRemountDepsOptionsUnion<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TRoute extends AnyRoute = ParseRoute<TRouteTree>,\n> = TRoute extends any\n  ? RemountDepsOptions<\n      TRoute['id'],\n      TRoute['types']['fullSearchSchema'],\n      TRoute['types']['allParams'],\n      TRoute['types']['loaderDeps']\n    >\n  : never\n\nexport interface BeforeLoadContextOptions<\n  in out TParentRoute extends AnyRoute,\n  in out TSearchValidator,\n  in out TParams,\n  in out TRouterContext,\n  in out TRouteContextFn,\n> extends ContextOptions<TParentRoute, TParams>,\n    FullSearchSchemaOption<TParentRoute, TSearchValidator> {\n  context: Expand<\n    BeforeLoadContextParameter<TParentRoute, TRouterContext, TRouteContextFn>\n  >\n}\n\ntype AssetFnContextOptions<\n  in out TRouteId,\n  in out TFullPath,\n  in out TParentRoute extends AnyRoute,\n  in out TParams,\n  in out TSearchValidator,\n  in out TLoaderFn,\n  in out TRouterContext,\n  in out TRouteContextFn,\n  in out TBeforeLoadFn,\n  in out TLoaderDeps,\n> = {\n  matches: Array<\n    RouteMatch<\n      TRouteId,\n      TFullPath,\n      ResolveAllParamsFromParent<TParentRoute, TParams>,\n      ResolveFullSearchSchema<TParentRoute, TSearchValidator>,\n      ResolveLoaderData<TLoaderFn>,\n      ResolveAllContext<\n        TParentRoute,\n        TRouterContext,\n        TRouteContextFn,\n        TBeforeLoadFn\n      >,\n      TLoaderDeps\n    >\n  >\n  match: RouteMatch<\n    TRouteId,\n    TFullPath,\n    ResolveAllParamsFromParent<TParentRoute, TParams>,\n    ResolveFullSearchSchema<TParentRoute, TSearchValidator>,\n    ResolveLoaderData<TLoaderFn>,\n    ResolveAllContext<\n      TParentRoute,\n      TRouterContext,\n      TRouteContextFn,\n      TBeforeLoadFn\n    >,\n    TLoaderDeps\n  >\n  params: ResolveAllParamsFromParent<TParentRoute, TParams>\n  loaderData: ResolveLoaderData<TLoaderFn>\n}\nexport interface UpdatableRouteOptions<\n  in out TParentRoute extends AnyRoute,\n  in out TRouteId,\n  in out TFullPath,\n  in out TParams,\n  in out TSearchValidator,\n  in out TLoaderFn,\n  in out TLoaderDeps,\n  in out TRouterContext,\n  in out TRouteContextFn,\n  in out TBeforeLoadFn,\n> extends UpdatableStaticRouteOption {\n  // If true, this route will be matched as case-sensitive\n  caseSensitive?: boolean\n  // If true, this route will be forcefully wrapped in a suspense boundary\n  wrapInSuspense?: boolean\n  // The content to be rendered when the route is matched. If no component is provided, defaults to `<Outlet />`\n  component?: RouteComponent\n  errorComponent?: false | null | ErrorRouteComponent\n  notFoundComponent?: NotFoundRouteComponent\n  pendingComponent?: RouteComponent\n  pendingMs?: number\n  pendingMinMs?: number\n  staleTime?: number\n  gcTime?: number\n  preload?: boolean\n  preloadStaleTime?: number\n  preloadGcTime?: number\n  search?: {\n    middlewares?: Array<\n      SearchMiddleware<\n        ResolveFullSearchSchemaInput<TParentRoute, TSearchValidator>\n      >\n    >\n  }\n  /** \n  @deprecated Use search.middlewares instead\n  */\n  preSearchFilters?: Array<\n    SearchFilter<ResolveFullSearchSchema<TParentRoute, TSearchValidator>>\n  >\n  /** \n  @deprecated Use search.middlewares instead\n  */\n  postSearchFilters?: Array<\n    SearchFilter<ResolveFullSearchSchema<TParentRoute, TSearchValidator>>\n  >\n  onCatch?: (error: Error, errorInfo: React.ErrorInfo) => void\n  onError?: (err: any) => void\n  // These functions are called as route matches are loaded, stick around and leave the active\n  // matches\n  onEnter?: (\n    match: RouteMatch<\n      TRouteId,\n      TFullPath,\n      ResolveAllParamsFromParent<TParentRoute, TParams>,\n      ResolveFullSearchSchema<TParentRoute, TSearchValidator>,\n      ResolveLoaderData<TLoaderFn>,\n      ResolveAllContext<\n        TParentRoute,\n        TRouterContext,\n        TRouteContextFn,\n        TBeforeLoadFn\n      >,\n      TLoaderDeps\n    >,\n  ) => void\n  onStay?: (\n    match: RouteMatch<\n      TRouteId,\n      TFullPath,\n      ResolveAllParamsFromParent<TParentRoute, TParams>,\n      ResolveFullSearchSchema<TParentRoute, TSearchValidator>,\n      ResolveLoaderData<TLoaderFn>,\n      ResolveAllContext<\n        TParentRoute,\n        TRouterContext,\n        TRouteContextFn,\n        TBeforeLoadFn\n      >,\n      TLoaderDeps\n    >,\n  ) => void\n  onLeave?: (\n    match: RouteMatch<\n      TRouteId,\n      TFullPath,\n      ResolveAllParamsFromParent<TParentRoute, TParams>,\n      ResolveFullSearchSchema<TParentRoute, TSearchValidator>,\n      ResolveLoaderData<TLoaderFn>,\n      ResolveAllContext<\n        TParentRoute,\n        TRouterContext,\n        TRouteContextFn,\n        TBeforeLoadFn\n      >,\n      TLoaderDeps\n    >,\n  ) => void\n  headers?: (ctx: {\n    loaderData: ResolveLoaderData<TLoaderFn>\n  }) => Record<string, string>\n  head?: (\n    ctx: AssetFnContextOptions<\n      TRouteId,\n      TFullPath,\n      TParentRoute,\n      TParams,\n      TSearchValidator,\n      TLoaderFn,\n      TRouterContext,\n      TRouteContextFn,\n      TBeforeLoadFn,\n      TLoaderDeps\n    >,\n  ) => {\n    links?: AnyRouteMatch['links']\n    scripts?: AnyRouteMatch['headScripts']\n    meta?: AnyRouteMatch['meta']\n  }\n  scripts?: (\n    ctx: AssetFnContextOptions<\n      TRouteId,\n      TFullPath,\n      TParentRoute,\n      TParams,\n      TSearchValidator,\n      TLoaderFn,\n      TRouterContext,\n      TRouteContextFn,\n      TBeforeLoadFn,\n      TLoaderDeps\n    >,\n  ) => AnyRouteMatch['scripts']\n  ssr?: boolean\n  codeSplitGroupings?: Array<\n    Array<\n      | 'loader'\n      | 'component'\n      | 'pendingComponent'\n      | 'notFoundComponent'\n      | 'errorComponent'\n    >\n  >\n}\n\nexport type RouteLoaderFn<\n  in out TParentRoute extends AnyRoute = AnyRoute,\n  in out TId extends string = string,\n  in out TParams = {},\n  in out TLoaderDeps = {},\n  in out TRouterContext = {},\n  in out TRouteContextFn = AnyContext,\n  in out TBeforeLoadFn = AnyContext,\n> = (\n  match: LoaderFnContext<\n    TParentRoute,\n    TId,\n    TParams,\n    TLoaderDeps,\n    TRouterContext,\n    TRouteContextFn,\n    TBeforeLoadFn\n  >,\n) => any\n\nexport interface LoaderFnContext<\n  in out TParentRoute extends AnyRoute = AnyRoute,\n  in out TId extends string = string,\n  in out TParams = {},\n  in out TLoaderDeps = {},\n  in out TRouterContext = {},\n  in out TRouteContextFn = AnyContext,\n  in out TBeforeLoadFn = AnyContext,\n> {\n  abortController: AbortController\n  preload: boolean\n  params: Expand<ResolveAllParamsFromParent<TParentRoute, TParams>>\n  deps: TLoaderDeps\n  context: Expand<\n    ResolveAllContext<\n      TParentRoute,\n      TRouterContext,\n      TRouteContextFn,\n      TBeforeLoadFn\n    >\n  >\n  location: ParsedLocation // Do not supply search schema here so as to demotivate people from trying to shortcut loaderDeps\n  /**\n   * @deprecated Use `throw redirect({ to: '/somewhere' })` instead\n   **/\n  navigate: (opts: NavigateOptions<AnyRouter>) => Promise<void> | void\n  // root route does not have a parent match\n  parentMatchPromise: TId extends RootRouteId\n    ? never\n    : Promise<MakeRouteMatchFromRoute<TParentRoute>>\n  cause: 'preload' | 'enter' | 'stay'\n  route: Route\n}\n\nexport type ResolveFullSearchSchema<\n  TParentRoute extends AnyRoute,\n  TSearchValidator,\n> = unknown extends TParentRoute\n  ? ResolveValidatorOutput<TSearchValidator>\n  : IntersectAssign<\n      InferFullSearchSchema<TParentRoute>,\n      ResolveValidatorOutput<TSearchValidator>\n    >\n\nexport type ResolveFullSearchSchemaInput<\n  TParentRoute extends AnyRoute,\n  TSearchValidator,\n> = IntersectAssign<\n  InferFullSearchSchemaInput<TParentRoute>,\n  ResolveSearchValidatorInput<TSearchValidator>\n>\n\nexport type RouteContextParameter<\n  TParentRoute extends AnyRoute,\n  TRouterContext,\n> = unknown extends TParentRoute\n  ? TRouterContext\n  : Assign<TRouterContext, InferAllContext<TParentRoute>>\n\nexport type BeforeLoadContextParameter<\n  TParentRoute extends AnyRoute,\n  TRouterContext,\n  TRouteContextFn,\n> = Assign<\n  RouteContextParameter<TParentRoute, TRouterContext>,\n  ContextReturnType<TRouteContextFn>\n>\n\nexport type ResolveAllContext<\n  TParentRoute extends AnyRoute,\n  TRouterContext,\n  TRouteContextFn,\n  TBeforeLoadFn,\n> = Assign<\n  BeforeLoadContextParameter<TParentRoute, TRouterContext, TRouteContextFn>,\n  ContextAsyncReturnType<TBeforeLoadFn>\n>\n\nexport interface AnyRoute\n  extends Route<\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  > {}\n\nexport type AnyRouteWithContext<TContext> = AnyRoute & {\n  types: { allContext: TContext }\n}\n\nexport type ResolveAllParamsFromParent<\n  TParentRoute extends AnyRoute,\n  TParams,\n> = Assign<InferAllParams<TParentRoute>, TParams>\n\nexport type RouteConstraints = {\n  TParentRoute: AnyRoute\n  TPath: string\n  TFullPath: string\n  TCustomId: string\n  TId: string\n  TSearchSchema: AnySchema\n  TFullSearchSchema: AnySchema\n  TParams: Record<string, any>\n  TAllParams: Record<string, any>\n  TParentContext: AnyContext\n  TRouteContext: RouteContext\n  TAllContext: AnyContext\n  TRouterContext: AnyContext\n  TChildren: unknown\n  TRouteTree: AnyRoute\n}\n\nexport type RouteTypesById<TRouter extends AnyRouter, TId> = RouteById<\n  TRouter['routeTree'],\n  TId\n>['types']\n\nexport function getRouteApi<\n  const TId,\n  TRouter extends AnyRouter = RegisteredRouter,\n>(id: ConstrainLiteral<TId, RouteIds<TRouter['routeTree']>>) {\n  return new RouteApi<TId, TRouter>({ id })\n}\n\nexport class RouteApi<TId, TRouter extends AnyRouter = RegisteredRouter> {\n  id: TId\n\n  /**\n   * @deprecated Use the `getRouteApi` function instead.\n   */\n  constructor({ id }: { id: TId }) {\n    this.id = id as any\n  }\n\n  useMatch: UseMatchRoute<TId> = (opts) => {\n    return useMatch({\n      select: opts?.select,\n      from: this.id,\n      structuralSharing: opts?.structuralSharing,\n    } as any) as any\n  }\n\n  useRouteContext: UseRouteContextRoute<TId> = (opts) => {\n    return useMatch({\n      from: this.id as any,\n      select: (d) => (opts?.select ? opts.select(d.context) : d.context),\n    }) as any\n  }\n\n  useSearch: UseSearchRoute<TId> = (opts) => {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    return useSearch({\n      select: opts?.select,\n      structuralSharing: opts?.structuralSharing,\n      from: this.id,\n    } as any) as any\n  }\n\n  useParams: UseParamsRoute<TId> = (opts) => {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    return useParams({\n      select: opts?.select,\n      structuralSharing: opts?.structuralSharing,\n      from: this.id,\n    } as any) as any\n  }\n\n  useLoaderDeps: UseLoaderDepsRoute<TId> = (opts) => {\n    return useLoaderDeps({ ...opts, from: this.id, strict: false } as any)\n  }\n\n  useLoaderData: UseLoaderDataRoute<TId> = (opts) => {\n    return useLoaderData({ ...opts, from: this.id, strict: false } as any)\n  }\n\n  useNavigate = (): UseNavigateResult<\n    RouteTypesById<TRouter, TId>['fullPath']\n  > => {\n    return useNavigate({ from: this.id as string })\n  }\n\n  notFound = (opts?: NotFoundError) => {\n    return notFound({ routeId: this.id as string, ...opts })\n  }\n}\n\nexport class Route<\n  in out TParentRoute extends RouteConstraints['TParentRoute'] = AnyRoute,\n  in out TPath extends RouteConstraints['TPath'] = '/',\n  in out TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<\n    TParentRoute,\n    TPath\n  >,\n  in out TCustomId extends RouteConstraints['TCustomId'] = string,\n  in out TId extends RouteConstraints['TId'] = ResolveId<\n    TParentRoute,\n    TCustomId,\n    TPath\n  >,\n  in out TSearchValidator = undefined,\n  in out TParams = ResolveParams<TPath>,\n  in out TRouterContext = AnyContext,\n  in out TRouteContextFn = AnyContext,\n  in out TBeforeLoadFn = AnyContext,\n  in out TLoaderDeps extends Record<string, any> = {},\n  in out TLoaderFn = undefined,\n  in out TChildren = unknown,\n> {\n  isRoot: TParentRoute extends Route<any> ? true : false\n  options: RouteOptions<\n    TParentRoute,\n    TId,\n    TCustomId,\n    TFullPath,\n    TPath,\n    TSearchValidator,\n    TParams,\n    TLoaderDeps,\n    TLoaderFn,\n    TRouterContext,\n    TRouteContextFn,\n    TBeforeLoadFn\n  >\n\n  // The following properties are set up in this.init()\n  parentRoute!: TParentRoute\n  private _id!: TId\n  private _path!: TPath\n  private _fullPath!: TFullPath\n  private _to!: TrimPathRight<TFullPath>\n  private _ssr!: boolean\n\n  public get to() {\n    /* invariant(\n      this._to,\n      `trying to access property 'to' on a route which is not initialized yet. Route properties are only available after 'createRouter' completed.`,\n    )*/\n    return this._to\n  }\n\n  public get id() {\n    /* invariant(\n      this._id,\n      `trying to access property 'id' on a route which is not initialized yet. Route properties are only available after 'createRouter' completed.`,\n    )*/\n    return this._id\n  }\n\n  public get path() {\n    /* invariant(\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      this.isRoot || this._id || this._path,\n      `trying to access property 'path' on a route which is not initialized yet. Route properties are only available after 'createRouter' completed.`,\n    )*/\n    return this._path\n  }\n\n  public get fullPath() {\n    /* invariant(\n      this._fullPath,\n      `trying to access property 'fullPath' on a route which is not initialized yet. Route properties are only available after 'createRouter' completed.`,\n    )*/\n    return this._fullPath\n  }\n\n  public get ssr() {\n    return this._ssr\n  }\n\n  // Optional\n  children?: TChildren\n  originalIndex?: number\n  rank!: number\n  lazyFn?: () => Promise<LazyRoute<any>>\n  _lazyPromise?: Promise<void>\n  _componentsPromise?: Promise<Array<void>>\n\n  /**\n   * @deprecated Use the `createRoute` function instead.\n   */\n  constructor(\n    options?: RouteOptions<\n      TParentRoute,\n      TId,\n      TCustomId,\n      TFullPath,\n      TPath,\n      TSearchValidator,\n      TParams,\n      TLoaderDeps,\n      TLoaderFn,\n      TRouterContext,\n      TRouteContextFn,\n      TBeforeLoadFn\n    >,\n  ) {\n    this.options = (options as any) || {}\n\n    this.isRoot = !options?.getParentRoute as any\n    invariant(\n      !((options as any)?.id && (options as any)?.path),\n      `Route cannot have both an 'id' and a 'path' option.`,\n    )\n    ;(this as any).$$typeof = Symbol.for('react.memo')\n  }\n\n  types!: {\n    parentRoute: TParentRoute\n    path: TPath\n    to: TrimPathRight<TFullPath>\n    fullPath: TFullPath\n    customId: TCustomId\n    id: TId\n    searchSchema: ResolveValidatorOutput<TSearchValidator>\n    searchSchemaInput: ResolveSearchValidatorInput<TSearchValidator>\n    searchValidator: TSearchValidator\n    fullSearchSchema: ResolveFullSearchSchema<TParentRoute, TSearchValidator>\n    fullSearchSchemaInput: ResolveFullSearchSchemaInput<\n      TParentRoute,\n      TSearchValidator\n    >\n    params: TParams\n    allParams: ResolveAllParamsFromParent<TParentRoute, TParams>\n    routerContext: TRouterContext\n    routeContext: ResolveRouteContext<TRouteContextFn, TBeforeLoadFn>\n    routeContextFn: TRouteContextFn\n    beforeLoadFn: TBeforeLoadFn\n    allContext: ResolveAllContext<\n      TParentRoute,\n      TRouterContext,\n      TRouteContextFn,\n      TBeforeLoadFn\n    >\n    children: TChildren\n    loaderData: ResolveLoaderData<TLoaderFn>\n    loaderDeps: TLoaderDeps\n  }\n\n  init = (opts: { originalIndex: number; defaultSsr?: boolean }): void => {\n    this.originalIndex = opts.originalIndex\n\n    const options = this.options as\n      | (RouteOptions<\n          TParentRoute,\n          TId,\n          TCustomId,\n          TFullPath,\n          TPath,\n          TSearchValidator,\n          TParams,\n          TLoaderDeps,\n          TLoaderFn,\n          TRouterContext,\n          TRouteContextFn,\n          TBeforeLoadFn\n        > &\n          RoutePathOptionsIntersection<TCustomId, TPath>)\n      | undefined\n\n    const isRoot = !options?.path && !options?.id\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    this.parentRoute = this.options.getParentRoute?.()\n\n    if (isRoot) {\n      this._path = rootRouteId as TPath\n    } else {\n      invariant(\n        this.parentRoute,\n        `Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance.`,\n      )\n    }\n\n    let path: undefined | string = isRoot ? rootRouteId : options.path\n\n    // If the path is anything other than an index path, trim it up\n    if (path && path !== '/') {\n      path = trimPathLeft(path)\n    }\n\n    const customId = options?.id || path\n\n    // Strip the parentId prefix from the first level of children\n    let id = isRoot\n      ? rootRouteId\n      : joinPaths([\n          this.parentRoute.id === rootRouteId ? '' : this.parentRoute.id,\n          customId,\n        ])\n\n    if (path === rootRouteId) {\n      path = '/'\n    }\n\n    if (id !== rootRouteId) {\n      id = joinPaths(['/', id])\n    }\n\n    const fullPath =\n      id === rootRouteId ? '/' : joinPaths([this.parentRoute.fullPath, path])\n\n    this._path = path as TPath\n    this._id = id as TId\n    // this.customId = customId as TCustomId\n    this._fullPath = fullPath as TFullPath\n    this._to = fullPath as TrimPathRight<TFullPath>\n    this._ssr = options?.ssr ?? opts.defaultSsr ?? true\n  }\n\n  addChildren<const TNewChildren>(\n    children: Constrain<\n      TNewChildren,\n      ReadonlyArray<AnyRoute> | Record<string, AnyRoute>\n    >,\n  ): Route<\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TCustomId,\n    TId,\n    TSearchValidator,\n    TParams,\n    TRouterContext,\n    TRouteContextFn,\n    TBeforeLoadFn,\n    TLoaderDeps,\n    TLoaderFn,\n    TNewChildren\n  > {\n    return this._addFileChildren(children) as Route<\n      TParentRoute,\n      TPath,\n      TFullPath,\n      TCustomId,\n      TId,\n      TSearchValidator,\n      TParams,\n      TRouterContext,\n      TRouteContextFn,\n      TBeforeLoadFn,\n      TLoaderDeps,\n      TLoaderFn,\n      TNewChildren\n    >\n  }\n\n  _addFileChildren<const TNewChildren>(\n    children: TNewChildren,\n  ): Route<\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TCustomId,\n    TId,\n    TSearchValidator,\n    TParams,\n    TRouterContext,\n    TRouteContextFn,\n    TBeforeLoadFn,\n    TLoaderDeps,\n    TLoaderFn,\n    TNewChildren\n  > {\n    if (Array.isArray(children)) {\n      this.children = children as TChildren\n    }\n\n    if (typeof children === 'object' && children !== null) {\n      this.children = Object.values(children) as TChildren\n    }\n\n    return this as unknown as Route<\n      TParentRoute,\n      TPath,\n      TFullPath,\n      TCustomId,\n      TId,\n      TSearchValidator,\n      TParams,\n      TRouterContext,\n      TRouteContextFn,\n      TBeforeLoadFn,\n      TLoaderDeps,\n      TLoaderFn,\n      TNewChildren\n    >\n  }\n\n  updateLoader = <TNewLoaderFn>(options: {\n    loader: Constrain<\n      TNewLoaderFn,\n      RouteLoaderFn<\n        TParentRoute,\n        TCustomId,\n        TParams,\n        TLoaderDeps,\n        TRouterContext,\n        TRouteContextFn,\n        TBeforeLoadFn\n      >\n    >\n  }) => {\n    Object.assign(this.options, options)\n    return this as unknown as Route<\n      TParentRoute,\n      TPath,\n      TFullPath,\n      TCustomId,\n      TId,\n      TSearchValidator,\n      TParams,\n      TRouterContext,\n      TRouteContextFn,\n      TBeforeLoadFn,\n      TLoaderDeps,\n      TNewLoaderFn,\n      TChildren\n    >\n  }\n\n  update = (\n    options: UpdatableRouteOptions<\n      TParentRoute,\n      TCustomId,\n      TFullPath,\n      TParams,\n      TSearchValidator,\n      TLoaderFn,\n      TLoaderDeps,\n      TRouterContext,\n      TRouteContextFn,\n      TBeforeLoadFn\n    >,\n  ): this => {\n    Object.assign(this.options, options)\n    return this\n  }\n\n  lazy = (lazyFn: () => Promise<LazyRoute<any>>): this => {\n    this.lazyFn = lazyFn\n    return this\n  }\n\n  useMatch: UseMatchRoute<TId> = (opts) => {\n    return useMatch({\n      select: opts?.select,\n      from: this.id,\n      structuralSharing: opts?.structuralSharing,\n    } as any) as any\n  }\n\n  useRouteContext: UseRouteContextRoute<TId> = (opts?) => {\n    return useMatch({\n      ...opts,\n      from: this.id,\n      select: (d) => (opts?.select ? opts.select(d.context) : d.context),\n    }) as any\n  }\n\n  useSearch: UseSearchRoute<TId> = (opts) => {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    return useSearch({\n      select: opts?.select,\n      structuralSharing: opts?.structuralSharing,\n      from: this.id,\n    } as any) as any\n  }\n\n  useParams: UseParamsRoute<TId> = (opts) => {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    return useParams({\n      select: opts?.select,\n      structuralSharing: opts?.structuralSharing,\n      from: this.id,\n    } as any) as any\n  }\n\n  useLoaderDeps: UseLoaderDepsRoute<TId> = (opts) => {\n    return useLoaderDeps({ ...opts, from: this.id } as any)\n  }\n\n  useLoaderData: UseLoaderDataRoute<TId> = (opts) => {\n    return useLoaderData({ ...opts, from: this.id } as any)\n  }\n\n  useNavigate = (): UseNavigateResult<TFullPath> => {\n    return useNavigate({ from: this.id })\n  }\n}\n\nexport function createRoute<\n  TParentRoute extends RouteConstraints['TParentRoute'] = AnyRoute,\n  TPath extends RouteConstraints['TPath'] = '/',\n  TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<\n    TParentRoute,\n    TPath\n  >,\n  TCustomId extends RouteConstraints['TCustomId'] = string,\n  TId extends RouteConstraints['TId'] = ResolveId<\n    TParentRoute,\n    TCustomId,\n    TPath\n  >,\n  TSearchValidator = undefined,\n  TParams = ResolveParams<TPath>,\n  TRouteContextFn = AnyContext,\n  TBeforeLoadFn = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderFn = undefined,\n  TChildren = unknown,\n>(\n  options: RouteOptions<\n    TParentRoute,\n    TId,\n    TCustomId,\n    TFullPath,\n    TPath,\n    TSearchValidator,\n    TParams,\n    TLoaderDeps,\n    TLoaderFn,\n    AnyContext,\n    TRouteContextFn,\n    TBeforeLoadFn\n  >,\n) {\n  return new Route<\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TCustomId,\n    TId,\n    TSearchValidator,\n    TParams,\n    AnyContext,\n    TRouteContextFn,\n    TBeforeLoadFn,\n    TLoaderDeps,\n    TLoaderFn,\n    TChildren\n  >(options)\n}\n\nexport type AnyRootRoute = RootRoute<any, any, any, any, any, any, any, any>\n\nexport type RootRouteOptions<\n  TSearchValidator = undefined,\n  TRouterContext = {},\n  TRouteContextFn = AnyContext,\n  TBeforeLoadFn = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderFn = undefined,\n> = Omit<\n  RouteOptions<\n    any, // TParentRoute\n    RootRouteId, // TId\n    RootRouteId, // TCustomId\n    '', // TFullPath\n    '', // TPath\n    TSearchValidator,\n    {}, // TParams\n    TLoaderDeps,\n    TLoaderFn,\n    TRouterContext,\n    TRouteContextFn,\n    TBeforeLoadFn\n  >,\n  | 'path'\n  | 'id'\n  | 'getParentRoute'\n  | 'caseSensitive'\n  | 'parseParams'\n  | 'stringifyParams'\n  | 'params'\n>\n\nexport function createRootRouteWithContext<TRouterContext extends {}>() {\n  return <\n    TRouteContextFn = AnyContext,\n    TBeforeLoadFn = AnyContext,\n    TSearchValidator = undefined,\n    TLoaderDeps extends Record<string, any> = {},\n    TLoaderFn = undefined,\n  >(\n    options?: RootRouteOptions<\n      TSearchValidator,\n      TRouterContext,\n      TRouteContextFn,\n      TBeforeLoadFn,\n      TLoaderDeps,\n      TLoaderFn\n    >,\n  ) => {\n    return createRootRoute<\n      TSearchValidator,\n      TRouterContext,\n      TRouteContextFn,\n      TBeforeLoadFn,\n      TLoaderDeps,\n      TLoaderFn\n    >(options as any)\n  }\n}\n\n/**\n * @deprecated Use the `createRootRouteWithContext` function instead.\n */\nexport const rootRouteWithContext = createRootRouteWithContext\n\nexport class RootRoute<\n  in out TSearchValidator = undefined,\n  in out TRouterContext = {},\n  in out TRouteContextFn = AnyContext,\n  in out TBeforeLoadFn = AnyContext,\n  in out TLoaderDeps extends Record<string, any> = {},\n  in out TLoaderFn = undefined,\n  in out TChildren = unknown,\n  in out TFileRouteTypes = unknown,\n> extends Route<\n  any, // TParentRoute\n  '/', // TPath\n  '/', // TFullPath\n  string, // TCustomId\n  RootRouteId, // TId\n  TSearchValidator, // TSearchValidator\n  {}, // TParams\n  TRouterContext,\n  TRouteContextFn,\n  TBeforeLoadFn,\n  TLoaderDeps,\n  TLoaderFn,\n  TChildren // TChildren\n> {\n  /**\n   * @deprecated `RootRoute` is now an internal implementation detail. Use `createRootRoute()` instead.\n   */\n  constructor(\n    options?: RootRouteOptions<\n      TSearchValidator,\n      TRouterContext,\n      TRouteContextFn,\n      TBeforeLoadFn,\n      TLoaderDeps,\n      TLoaderFn\n    >,\n  ) {\n    super(options as any)\n  }\n\n  addChildren<const TNewChildren>(\n    children: Constrain<\n      TNewChildren,\n      ReadonlyArray<AnyRoute> | Record<string, AnyRoute>\n    >,\n  ): RootRoute<\n    TSearchValidator,\n    TRouterContext,\n    TRouteContextFn,\n    TBeforeLoadFn,\n    TLoaderDeps,\n    TLoaderFn,\n    TNewChildren,\n    TFileRouteTypes\n  > {\n    super.addChildren(children)\n    return this as unknown as RootRoute<\n      TSearchValidator,\n      TRouterContext,\n      TRouteContextFn,\n      TBeforeLoadFn,\n      TLoaderDeps,\n      TLoaderFn,\n      TNewChildren,\n      TFileRouteTypes\n    >\n  }\n\n  _addFileChildren<const TNewChildren>(\n    children: TNewChildren,\n  ): RootRoute<\n    TSearchValidator,\n    TRouterContext,\n    TRouteContextFn,\n    TBeforeLoadFn,\n    TLoaderDeps,\n    TLoaderFn,\n    TNewChildren,\n    TFileRouteTypes\n  > {\n    super._addFileChildren(children)\n    return this as unknown as RootRoute<\n      TSearchValidator,\n      TRouterContext,\n      TRouteContextFn,\n      TBeforeLoadFn,\n      TLoaderDeps,\n      TLoaderFn,\n      TNewChildren,\n      TFileRouteTypes\n    >\n  }\n\n  _addFileTypes<TFileRouteTypes>(): RootRoute<\n    TSearchValidator,\n    TRouterContext,\n    TRouteContextFn,\n    TBeforeLoadFn,\n    TLoaderDeps,\n    TLoaderFn,\n    TChildren,\n    TFileRouteTypes\n  > {\n    return this as any\n  }\n}\n\nexport function createRootRoute<\n  TSearchValidator = undefined,\n  TRouterContext = {},\n  TRouteContextFn = AnyContext,\n  TBeforeLoadFn = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderFn = undefined,\n>(\n  options?: RootRouteOptions<\n    TSearchValidator,\n    TRouterContext,\n    TRouteContextFn,\n    TBeforeLoadFn,\n    TLoaderDeps,\n    TLoaderFn\n  >,\n) {\n  return new RootRoute<\n    TSearchValidator,\n    TRouterContext,\n    TRouteContextFn,\n    TBeforeLoadFn,\n    TLoaderDeps,\n    TLoaderFn\n  >(options)\n}\n\nexport type ResolveFullPath<\n  TParentRoute extends AnyRoute,\n  TPath extends string,\n  TPrefixed = RoutePrefix<TParentRoute['fullPath'], TPath>,\n> = TPrefixed extends RootRouteId ? '/' : TPrefixed\n\nexport type RouteMask<TRouteTree extends AnyRoute> = {\n  routeTree: TRouteTree\n  from: RoutePaths<TRouteTree>\n  to?: any\n  params?: any\n  search?: any\n  hash?: any\n  state?: any\n  unmaskOnReload?: boolean\n}\n\nexport function createRouteMask<\n  TRouteTree extends AnyRoute,\n  TFrom extends string,\n  TTo extends string,\n>(\n  opts: {\n    routeTree: TRouteTree\n  } & ToMaskOptions<Router<TRouteTree, 'never', boolean>, TFrom, TTo>,\n): RouteMask<TRouteTree> {\n  return opts as any\n}\n\nexport type ReactNode = any\n\nexport type SyncRouteComponent<TProps> =\n  | ((props: TProps) => ReactNode)\n  | React.LazyExoticComponent<(props: TProps) => ReactNode>\n\nexport type AsyncRouteComponent<TProps> = SyncRouteComponent<TProps> & {\n  preload?: () => Promise<void>\n}\n\nexport type RouteComponent<TProps = any> = AsyncRouteComponent<TProps>\n\nexport type ErrorRouteComponent = RouteComponent<ErrorComponentProps>\n\nexport type NotFoundRouteComponent = SyncRouteComponent<NotFoundRouteProps>\n\nexport class NotFoundRoute<\n  TParentRoute extends AnyRootRoute,\n  TRouterContext = AnyContext,\n  TRouteContextFn = AnyContext,\n  TBeforeLoadFn = AnyContext,\n  TSearchValidator = undefined,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderFn = undefined,\n  TChildren = unknown,\n> extends Route<\n  TParentRoute,\n  '/404',\n  '/404',\n  '404',\n  '404',\n  TSearchValidator,\n  {},\n  TRouterContext,\n  TRouteContextFn,\n  TBeforeLoadFn,\n  TLoaderDeps,\n  TLoaderFn,\n  TChildren\n> {\n  constructor(\n    options: Omit<\n      RouteOptions<\n        TParentRoute,\n        string,\n        string,\n        string,\n        string,\n        TSearchValidator,\n        {},\n        TLoaderDeps,\n        TLoaderFn,\n        TRouterContext,\n        TRouteContextFn,\n        TBeforeLoadFn\n      >,\n      | 'caseSensitive'\n      | 'parseParams'\n      | 'stringifyParams'\n      | 'path'\n      | 'id'\n      | 'params'\n    >,\n  ) {\n    super({\n      ...(options as any),\n      id: '404',\n    })\n  }\n}\n"],"names":["useMatch","useSearch","useParams","useLoaderDeps","useLoaderData","useNavigate","notFound","options","rootRouteId","trimPathLeft","joinPaths"],"mappings":"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"}