import { StructuralSharingOption, ValidateSelected } from './structuralSharing.js';
import { AnyRoute, ReactNode } from './route.js';
import { ControlledPromise, DeepPartial, NoInfer, ResolveRelativePath, StaticDataRouteOption } from '@tanstack/router-core';
import { AnyRouter, RegisteredRouter } from './router.js';
import { MakeOptionalPathParams, MakeOptionalSearchParams, MaskOptions, ResolveRoute, ToSubOptionsProps } from './link.js';
import { AllContext, AllLoaderData, AllParams, FullSearchSchema, ParseRoute, RouteById, RouteByPath, RouteIds } from './routeInfo.js';
import * as React from 'react';
export type MakeRouteMatchFromRoute<TRoute extends AnyRoute> = RouteMatch<TRoute['types']['id'], TRoute['types']['fullPath'], TRoute['types']['allParams'], TRoute['types']['fullSearchSchema'], TRoute['types']['loaderData'], TRoute['types']['allContext'], TRoute['types']['loaderDeps']>;
export interface RouteMatch<out TRouteId, out TFullPath, out TAllParams, out TFullSearchSchema, out TLoaderData, out TAllContext, out TLoaderDeps> {
    id: string;
    routeId: TRouteId;
    fullPath: TFullPath;
    index: number;
    pathname: string;
    params: TAllParams;
    _strictParams: TAllParams;
    status: 'pending' | 'success' | 'error' | 'redirected' | 'notFound';
    isFetching: false | 'beforeLoad' | 'loader';
    error: unknown;
    paramsError: unknown;
    searchError: unknown;
    updatedAt: number;
    loadPromise?: ControlledPromise<void>;
    beforeLoadPromise?: ControlledPromise<void>;
    loaderPromise?: ControlledPromise<void>;
    loaderData?: TLoaderData;
    __routeContext: Record<string, unknown>;
    __beforeLoadContext: Record<string, unknown>;
    context: TAllContext;
    search: TFullSearchSchema;
    _strictSearch: TFullSearchSchema;
    fetchCount: number;
    abortController: AbortController;
    cause: 'preload' | 'enter' | 'stay';
    loaderDeps: TLoaderDeps;
    preload: boolean;
    invalid: boolean;
    meta?: Array<React.JSX.IntrinsicElements['meta'] | undefined>;
    links?: Array<React.JSX.IntrinsicElements['link'] | undefined>;
    scripts?: Array<React.JSX.IntrinsicElements['script'] | undefined>;
    headScripts?: Array<React.JSX.IntrinsicElements['script'] | undefined>;
    headers?: Record<string, string>;
    globalNotFound?: boolean;
    staticData: StaticDataRouteOption;
    minPendingPromise?: ControlledPromise<void>;
    pendingTimeout?: ReturnType<typeof setTimeout>;
}
export type MakeRouteMatch<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TRouteId = RouteIds<TRouteTree>, TStrict extends boolean = true> = RouteMatch<TRouteId, RouteById<TRouteTree, TRouteId>['types']['fullPath'], TStrict extends false ? AllParams<TRouteTree> : RouteById<TRouteTree, TRouteId>['types']['allParams'], TStrict extends false ? FullSearchSchema<TRouteTree> : RouteById<TRouteTree, TRouteId>['types']['fullSearchSchema'], TStrict extends false ? AllLoaderData<TRouteTree> : RouteById<TRouteTree, TRouteId>['types']['loaderData'], TStrict extends false ? AllContext<TRouteTree> : RouteById<TRouteTree, TRouteId>['types']['allContext'], RouteById<TRouteTree, TRouteId>['types']['loaderDeps']>;
export type AnyRouteMatch = RouteMatch<any, any, any, any, any, any, any>;
export declare function Matches(): import("react/jsx-runtime").JSX.Element;
export interface MatchRouteOptions {
    pending?: boolean;
    caseSensitive?: boolean;
    includeSearch?: boolean;
    fuzzy?: boolean;
}
export type UseMatchRouteOptions<TRouter extends AnyRouter = RegisteredRouter, TFrom extends string = string, TTo extends string | undefined = undefined, TMaskFrom extends string = TFrom, TMaskTo extends string = ''> = ToSubOptionsProps<TRouter, TFrom, TTo> & DeepPartial<MakeOptionalSearchParams<TRouter, TFrom, TTo>> & DeepPartial<MakeOptionalPathParams<TRouter, TFrom, TTo>> & MaskOptions<TRouter, TMaskFrom, TMaskTo> & MatchRouteOptions;
export declare function useMatchRoute<TRouter extends AnyRouter = RegisteredRouter>(): <const TFrom extends string = string, const TTo extends string | undefined = undefined, const TMaskFrom extends string = TFrom, const TMaskTo extends string = "">(opts: UseMatchRouteOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>) => false | ResolveRoute<TRouter, TFrom, TTo>["types"]["allParams"];
export type MakeMatchRouteOptions<TRouter extends AnyRouter = RegisteredRouter, TFrom extends string = string, TTo extends string | undefined = undefined, TMaskFrom extends string = TFrom, TMaskTo extends string = ''> = UseMatchRouteOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo> & {
    children?: ((params?: RouteByPath<TRouter['routeTree'], ResolveRelativePath<TFrom, NoInfer<TTo>>>['types']['allParams']) => ReactNode) | React.ReactNode;
};
export declare function MatchRoute<TRouter extends AnyRouter = RegisteredRouter, const TFrom extends string = string, const TTo extends string | undefined = undefined, const TMaskFrom extends string = TFrom, const TMaskTo extends string = ''>(props: MakeMatchRouteOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>): any;
export type MakeRouteMatchUnion<TRouter extends AnyRouter = RegisteredRouter, TRoute extends AnyRoute = ParseRoute<TRouter['routeTree']>> = TRoute extends any ? RouteMatch<TRoute['id'], TRoute['fullPath'], TRoute['types']['allParams'], TRoute['types']['fullSearchSchema'], TRoute['types']['loaderData'], TRoute['types']['allContext'], TRoute['types']['loaderDeps']> : never;
export interface UseMatchesBaseOptions<TRouter extends AnyRouter, TSelected, TStructuralSharing> {
    select?: (matches: Array<MakeRouteMatchUnion<TRouter>>) => ValidateSelected<TRouter, TSelected, TStructuralSharing>;
}
export type UseMatchesResult<TRouter extends AnyRouter, TSelected> = unknown extends TSelected ? Array<MakeRouteMatchUnion<TRouter>> : TSelected;
export declare function useMatches<TRouter extends AnyRouter = RegisteredRouter, TSelected = unknown, TStructuralSharing extends boolean = boolean>(opts?: UseMatchesBaseOptions<TRouter, TSelected, TStructuralSharing> & StructuralSharingOption<TRouter, TSelected, TStructuralSharing>): UseMatchesResult<TRouter, TSelected>;
export declare function useParentMatches<TRouter extends AnyRouter = RegisteredRouter, TSelected = unknown, TStructuralSharing extends boolean = boolean>(opts?: UseMatchesBaseOptions<TRouter, TSelected, TStructuralSharing> & StructuralSharingOption<TRouter, TSelected, TStructuralSharing>): UseMatchesResult<TRouter, TSelected>;
export declare function useChildMatches<TRouter extends AnyRouter = RegisteredRouter, TSelected = unknown, TStructuralSharing extends boolean = boolean>(opts?: UseMatchesBaseOptions<TRouter, TSelected, TStructuralSharing> & StructuralSharingOption<TRouter, TSelected, TStructuralSharing>): UseMatchesResult<TRouter, TSelected>;
